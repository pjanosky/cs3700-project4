#!/usr/bin/env -S python3 -u

import argparse
import socket
import json
import select
import sys
import zlib
import time
from functools import reduce

# constants
DATA_SIZE = 1425  # the maximum amount of data sent in one packet
MAX_MSG_SIZE = 65535  # the maximum size of a message in bytes that the sender expects to receive
ALPHA = 0.875  # the constant that for update the RTT estimate


# represents on data packet that is sent to the receiver
class Packet:
    def __init__(self, data, acked, send_time):
        self.data = data
        self.acked = acked
        self.send_time = send_time

    # was this packet sent already
    def was_sent(self):
        return self.send_time is not None

    # is this packet in transit (sent but not acked)
    def in_transit(self):
        return self.was_sent() and not self.acked


# Handles sending data packets and receiving ACks
class Sender:
    def __init__(self, host, port):
        self.host = host
        self.remote_port = int(port)
        log("Sender starting up using port %s" % self.remote_port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        self.packets = [] # all packets that have been sent to the receiver
        self.rtt = 1000   # the estimated RTT in milliseconds
        self.cgn_wnd = 1.0  # the maximum number of packets that can be simultaneously in transit
        self.ss_thresh = 15  # the threshold where congestion avoidance starts for the  congestion window

    # sends a string message to the receiver
    def send_msg(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))

    # run the sender program
    def run(self):
        # read input from the simulator
        self.read_input()

        # send data packets and respond to ACKs
        while True:
            inputs = [self.socket]
            connections = select.select(inputs, [], [], 0.05)[0]
            for conn in connections:
                self.recv_ack(conn)

            # resend dropped packets and send new packets within the current window
            self.resend_dropped()
            self.send_packets()

            # exit if all packets have been successfully received
            if self.ack_idx() == len(self.packets) - 1:
                log('All done!')
                exit(0)

    # read all input from the simulator to send to the receiver
    def read_input(self):
        data = sys.stdin.read(DATA_SIZE)
        while len(data) > 0:
            log('read data')
            self.packets.append(Packet(data, False, None))
            data = sys.stdin.read(DATA_SIZE)
        log(f'number of packets: {len(self.packets)}')

    # handles receiving an ack from the receiver
    def recv_ack(self, conn):
        # parser ack message
        data, addr = conn.recvfrom(MAX_MSG_SIZE)
        msg = self.parse_ack(data)
        if msg is None:
            # packet was corrupted
            log('Received corrupted ACK')
        else:
            # packet was not corrupted
            log(f'Received ACK: {msg}')

            # mark packet as ACKed
            pkt = self.packets[msg['index']]
            pkt.acked = True

            # update RTT estimate and cogestion window
            self.rtt = ALPHA * self.rtt + (1 - ALPHA) * (now() - pkt.send_time)
            if self.cgn_wnd < self.ss_thresh:
                # slow start (multiplicative increase)
                self.cgn_wnd += 1
            else:
                # congestion avoidance (additive increase)
                self.cgn_wnd += 1 / self.cgn_wnd

    # resend packets that have not been ACKed withing a period of time
    def resend_dropped(self):
        timeout = now() - int(self.rtt) * 2

        # resend any packets that were sent before timeout
        for i, pkt in enumerate(self.packets):
            if not pkt.acked and pkt.was_sent() and pkt.send_time < timeout:
                # there was a timeout (pkt was dropped)
                log(f'--Resending data to receiver: index={i}')

                # adjust slow start threshold and congestion window
                self.ss_thresh = self.cgn_wnd / 2
                self.cgn_wnd = self.ss_thresh

                # resend packet
                self.send_packet(pkt, i)

    # sends all data messages not yet send withing the current window
    def send_packets(self):
        i = 0
        while i < len(self.packets) and self.in_transit() < int(self.cgn_wnd):
            pkt = self.packets[i]
            if not pkt.was_sent():
                log(f'Sending data to receiver: index={i}')
                self.send_packet(pkt, i)
            i += 1

    # sends a single packet
    def send_packet(self, pkt, i):
        pkt.send_time = now()
        msg = {'index': i, 'data': pkt.data}
        hash_value = zlib.crc32(json.dumps(msg, sort_keys=True).encode('utf-8'))
        msg = {'hash': hash_value, 'msg': msg}
        self.send_msg(msg)

    # Parses an ACK message from the receiver, ensuring that it hasn't been corrupted.
    @classmethod
    def parse_ack(cls, data):
        """

        Parameters:
            data (bytearray): the ack message data received

        Returns:
            dict: the parsed ack message corresponding to its JSON data
        """
        try:
            msg = json.loads(data.decode('utf-8'))
        except json.decoder.JSONDecodeError:
            return None

        if ('hash' in msg and
                'msg' in msg and
                'index' in msg['msg'] and
                zlib.crc32(json.dumps(msg['msg']).encode('utf-8')) == msg['hash']):
            return msg['msg']
        else:
            return None

    # the index of the last packet that has been ACKed
    def ack_idx(self):
        for i, pkt in enumerate(self.packets):
            if not pkt.acked:
                return i - 1
        return len(self.packets) - 1

    # Calculates the number of packets that are currently in transit
    def in_transit(self):
        return reduce(lambda total, pkt: total + (1 if pkt.in_transit() else 0), self.packets, 0)


def log(message):
    """
    print a debug message to STDERR

    Parameters:
        message (str): message to log
    """
    sys.stderr.write('-' + message + '\n')
    sys.stderr.flush()


def now():
    """
    Calculates the current time

    Returns
        int: the time since the epoch in milliseconds
    """
    return int(time.time() * 1000)


# parse the command line arguments for the sender program
def parse_args():
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help='Remote host to connect to')
    parser.add_argument('port', type=int, help='UDP port number to connect to')
    return parser.parse_args()


# run the sender program
if __name__ == '__main__':
    args = parse_args()
    sender = Sender(args.host, args.port)
    sender.run()
