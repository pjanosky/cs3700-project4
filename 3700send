#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, sys, zlib
from functools import reduce

from packet import Packet


DATA_SIZE = 1375  # the maximum amount of data sent in one packet
MAX_MSG_SIZE = 65535  # the maximum size of a message in bytes that the sender expects to receive
ALPHA = 0.875  # the constant that for update the RTT estimate


class Sender:

    def __init__(self, host, port):
        self.host = host
        self.remote_port = int(port)
        log("Sender starting up using port %s" % self.remote_port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        self.packets = []
        self.rtt = 1000  # the estimated RTT in milliseconds
        self.adv_wnd = 4.0
        self.cgn_wnd = 1.0
        self.ss_thresh = 15

    # sends a string message to the receiver
    def send_msg(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))

    # run the sender program
    def run(self):
        data = sys.stdin.read(DATA_SIZE)
        while len(data) > 0:
            log('read data')
            self.packets.append(Packet(data, False, None))
            data = sys.stdin.read(DATA_SIZE)
        log(f'number of packets: {len(self.packets)}')

        while True:
            # if self.seq_num < self.ack_num + self.wnd:
                # we can send more data
            inputs = [self.socket]
            # else:
            #     # we can't send more data
            #     inputs = [self.socket]

            connections = select.select(inputs, [], [], 0.05)[0]
            for conn in connections:
                # if conn == self.socket:
                self.recv_ack(conn)
                # elif conn == sys.stdin:
                #     self.recv_input()
            self.send_packets()
            self.resend_packets()
            log(f'WINDOW: {self.window()}, RTT: {self.rtt}, {"ss" if self.cgn_wnd < self.ss_thresh else "avoid"}')
            # self.log_unacked()

    # # handles receiving data from the simulator to send to the receiver
    # def recv_input(self):
    #     data = sys.stdin.read(DATA_SIZE)
    #     if len(data) > 0:
    #         log('read data')
    #         pkt = Packet(data, False, None)
    #         self.packets.append(pkt)

    # handles receiving an ack from the receiver
    def recv_ack(self, conn):
        # parser ack message
        data, addr = conn.recvfrom(MAX_MSG_SIZE)
        msg = self.valid_ack(data)
        if msg is None:
            # packet was corrupted
            log('Received corrupted ACK')
        else:
            # packet was not corrupted
            log(f'Received ACK: {msg}')

            # mark packet as ACKed
            pkt = self.packets[msg['index']]
            pkt.acked = True

            # update RTT estimate
            self.rtt = ALPHA * self.rtt + (1 - ALPHA) * (now() - pkt.send_time)

            # update congestion window
            if self.cgn_wnd < self.ss_thresh:
                # slow start (multiplicative increase)
                self.cgn_wnd += 1
            else:
                # congestion avoidance (additive increase)
                self.cgn_wnd += 1 / self.cgn_wnd

            # exit if all packets have been sucessfully received
            if self.ack_idx() == len(self.packets) - 1:
                log('All done!')
                exit(0)

    # sends all data messages not yet send withing the current window
    def send_packets(self):
        i = self.ack_idx() + 1
        while i < len(self.packets) and self.in_transit() < int(self.window()):
            pkt = self.packets[i]
            if not pkt.was_sent():
                log(f'Sending data to receiver: index={i}')
                self.send_packet(pkt, i)
            i += 1

    # retransmit any packets that have not been ACKed withing a period of time
    def resend_packets(self):
        timeout = now() - int(self.rtt) * 2

        # resend any packets that were sent before timeout
        for i, pkt in enumerate(self.packets):
            if not pkt.acked and pkt.was_sent() and pkt.send_time < timeout:
                # there was a timeout (pkt was dropped)
                log(f'--Resending data to receiver: index={i}')

                # adjust slow start threshold and congestion window
                self.ss_thresh = self.cgn_wnd / 2
                self.cgn_wnd = self.ss_thresh

                # resend packet
                self.send_packet(pkt, i)

    def send_packet(self, pkt, i):
        pkt.send_time = now()
        msg = {'index': i, 'data': pkt.data}
        hash_value = zlib.crc32(json.dumps(msg, sort_keys=True).encode('utf-8'))
        msg = {'hash': hash_value, 'msg': msg}
        self.send_msg(msg)

    def valid_ack(self, data):
        try:
            msg = json.loads(data.decode('utf-8'))
        except json.decoder.JSONDecodeError:
            return None

        if ('hash' in msg and
                'msg' in msg and
                'index' in msg['msg'] and
                zlib.crc32(json.dumps(msg['msg']).encode('utf-8')) == msg['hash']):
            return msg['msg']
        else:
            return None

    # the index of the last packet that has been ACKed
    def ack_idx(self):
        for i, pkt in enumerate(self.packets):
            if not pkt.acked:
                return i - 1
        return len(self.packets) - 1

    # the number of bytes that have been successfully ACKed
    def ack_num(self):
        total = 0
        for i, pkt in enumerate(self.packets):
            if not pkt.acked:
                return total
            else:
                total += len(pkt.data)
        return total

    # returns the number of packets that can be in transit (un-acked)
    def window(self):
        return self.cgn_wnd
        # return 42

    def in_transit(self):
        return reduce(lambda total, pkt: total + (1 if pkt.in_transit() else 0), self.packets, 0)

    def log_unacked(self):
        result = 'unacked packets: ['
        for i in range(0, len(self.packets)):
            pkt = self.packets[i]
            if (not pkt.acked) and pkt.was_sent():
                result += f'{i}, '
            elif pkt.acked:
                result += 'x, '
            else:
                result += '_, '
        log(result + ']')


# print a debug message to STDERR
def log(message):
    sys.stderr.write('-' + message + '\n')
    sys.stderr.flush()


# parse the command line arguments for the sender program
def parse_args():
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help='Remote host to connect to')
    parser.add_argument('port', type=int, help='UDP port number to connect to')
    return parser.parse_args()


# returns the current time since the epcoh in ms
def now():
    return int(time.time() * 1000)


# run the sender program
if __name__ == '__main__':  # TODO: search this
    args = parse_args()
    sender = Sender(args.host, args.port)
    sender.run()

# TODO: theres a problem with the ack/seq numbers and getting select to correctly scan stdin
