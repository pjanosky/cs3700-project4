#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, sys, zlib
from packet import Packet


DATA_SIZE = 1375  # the maximum amount of data sent in one packet
MAX_MSG_SIZE = 65535  # the maximum size of a message in bytes that the sender expects to receive


class Sender:
    def __init__(self, host, port):
        self.host = host
        self.remote_port = int(port)
        log("Sender starting up using port %s" % self.remote_port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        self.seq_num = 0
        self.seq_idx = -1
        self.packets = []
        self.rtt = 1000  # the estimated RTT in milliseconds

    # sends a string message to the receiver
    def send_msg(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))

    # run the sender program
    def run(self):
        while True:
            # if self.seq_num < self.ack_num + self.wnd:
                # we can send more data
            inputs = [self.socket, sys.stdin]
            # else:
            #     # we can't send more data
            #     inputs = [self.socket]

            connections = select.select(inputs, [], [], 0.05)[0]
            for conn in connections:
                if conn == self.socket:
                    self.recv_ack(conn)
                elif conn == sys.stdin:
                    self.recv_input()
            self.send_packets()
            self.resend_packets()

    # handles receiving data from the simulator to send to the receiver
    def recv_input(self):
        data = sys.stdin.read(DATA_SIZE)
        if len(data) > 0:
            log('read data')
            pkt = Packet(data, False, None)
            self.packets.append(pkt)

    # handles receiving an ack from the receiver
    def recv_ack(self, conn):
        data, addr = conn.recvfrom(MAX_MSG_SIZE)
        msg = self.valid_ack(data)
        if msg is None:
            log('Received corrupted ACK')
        else:
            log(f'Received ACK: {msg}')
            self.packets[msg['index']].acked = True

            if self.ack_idx() == len(self.packets) - 1:
                log('All done!')
                exit(0)

            self.log_unacked()

    # sends all data messages not yet send withing the current window
    def send_packets(self):
        i = self.seq_idx + 1
        while i < len(self.packets) and self.seq_num < self.window():
            pkt = self.packets[i]
            log(f'Sending data to receiver: index={i}')
            self.send_packet(pkt, i)
            self.seq_idx += 1
            self.seq_num += len(pkt.data)
            i += 1

    # retransmit any packets that have not been ACKed withing a period of time
    def resend_packets(self):
        timeout = now() - self.rtt * 2
        # resend any packets that were sent before timeout
        for i, pkt in enumerate(self.packets):
            if not pkt.acked and pkt.was_sent() and pkt.send_time < timeout:
                log(f'Resending data to receiver: index={i}')
                self.send_packet(pkt, i)

    def send_packet(self, pkt, i):
        pkt.send_time = now()
        msg = {'index': i, 'data': pkt.data}
        hash_value = zlib.crc32(json.dumps(msg, sort_keys=True).encode('utf-8'))
        msg = {'hash': hash_value, 'msg': msg}
        self.log_unacked()
        self.send_msg(msg)

    def valid_ack(self, data):
        try:
            msg = json.loads(data.decode('utf-8'))
        except json.decoder.JSONDecodeError:
            return None

        if ('hash' in msg and
                'msg' in msg and
                'index' in msg['msg'] and
                zlib.crc32(json.dumps(msg['msg']).encode('utf-8')) == msg['hash']):
            return msg['msg']
        else:
            return None

    # the index of the last packet that has been ACKed
    def ack_idx(self):
        for i, pkt in enumerate(self.packets):
            if not pkt.acked:
                return i - 1
        return len(self.packets) - 1

    # the number of bytes that have been successfully ACKed
    def ack_num(self):
        total = 0
        for i, pkt in enumerate(self.packets):
            if not pkt.acked:
                return total
            else:
                total += len(pkt.data)
        return total

    def window(self):
        return self.ack_num() + DATA_SIZE * 4

    def log_unacked(self):
        result = 'unacked packets: ['
        for i in range(0, len(self.packets)):
            pkt = self.packets[i]
            result += f'{i if (not pkt.acked) and pkt.was_sent() else "_"}, '
        log(result + ']')


# print a debug message to STDERR
def log(message):
    sys.stderr.write('-' + message + '\n')
    sys.stderr.flush()


# parse the command line arguments for the sender program
def parse_args():
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help='Remote host to connect to')
    parser.add_argument('port', type=int, help='UDP port number to connect to')
    return parser.parse_args()


# returns the current time since the epcoh in ms
def now():
    return int(time.time() * 1000)


# run the sender program
if __name__ == '__main__':  # TODO: search this
    args = parse_args()
    sender = Sender(args.host, args.port)
    sender.run()

# TODO: theres a problem with the ack/seq numbers and getting select to correctly scan stdin
